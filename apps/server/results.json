[
  {
    "embedding_id": "1b2ee685-fad4-4c3d-a0b9-145021603306",
    "matched_chunk": "Get my new Bodybuilding Transformation System (25% off code TRANSFORM): [https://jeffnippard.com/products/the-...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqblNpTWQxRVBLSHFCNklWbzRnbEhOcjlpbmxoQXxBQ3Jtc0tuRGdRSHBYeUpWTHVIQU55ZldxRUNfV0Q2SUxpSWpnVGxNM0c4bXJ4WjZod2VuS0FtRUk3TzN4MVdwbTZHNWtsc1VTaE1rOWxXdmFDSG41WW9pcUZxN0RUaG9mZmVvYmNoNTE2MU9meFd0SUNhem5XYw&q=https%3A%2F%2Fjeffnippard.com%2Fproducts%2Fthe-bodybuilding-transformation-system&v=928aRhhPP8I) My Nutrition App: [http://bit.ly/jeffmacrofactor](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqazUwQ2VjQldEdjVwdWVCdFRiVEE0RllQNkN4d3xBQ3Jtc0tsYlRwMHJLdVUzekstY1F3dDVnQmxrb0dEQ1ZBbzNfSG9TV3NOdTZaQ2pBVlZZX3BGZk5JejRITVVUYVAtYVlMMkRlSEwzZ2NVa05jTS0zcUp6SlhqTFNvaHR4VUQtVV9JMkpYZHpWZHF5Z2JyTHdJWQ&q=http%3A%2F%2Fbit.ly%2Fjeffmacrofactor&v=928aRhhPP8I) (Use code Jeff for a FREE 2 week trial) ------------------------------- Summary: In this video, I break down the exact upper body workout I used during my 365-day experiment. Iâ€™ll explain why I chose each exercise over similar options, share key technique cues, and highlight common mistakes to avoid. References: Incline Bench Press Hypertrophy [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGFkcDB3blVhb3pmelVLNHdaZkcyNWI1dUdIQXxBQ3Jtc0tuNmFydGpvSHBSZVlPX0doUFJydDllaGMwZlhMNjRNdEZWcjFUZERzYnpaVU9HU3BhVjlJTnN2STNFaE1VaFZKeWJDcnlVUTdaQlZDWV9VQU0wd2htNS05YXh5MFVNMDZwOXVIUlFtV2htcVFoZ0xBdw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC7449336%2F&v=928aRhhPP8I) Cable vs Dumbbell Lateral Raise [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbjN5QnFld0RIZ1hESkZOVEQ0QmJwblhzcmhiZ3xBQ3Jtc0ttemZrWmZqdXQ3amFmSEo2aG1NcXZaNXJQazc2YUlsbloxOFlfcUhLZnpTcVA1ZFFONGFWbkg5aDZzN0RLTlBXaUlvZ1RHS1d1Z1kxYkk1eEM2NWcwNmRVVFZuTUt3OEN3LU5PVkdlYTV3d192dkpkRQ&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F387157135&v=928aRhhPP8I) Biceps Studies [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqa2IydUVGaV9kaW1EU1dyUFlJWHZGb29CdUZhQXxBQ3Jtc0ttNWVmcHdqUy1oRkdvYlNLM0dTX1U2d3QxZHdCVENfTkxhdjZLTnNzWUE0WGozX3FHbXNraFA5ZWliQ3RiOW9JY1ZlM0s0U0tZd1ZlMUVFR3VXV2F3Ul9RTlZVOTVjWjJLbUR4d082ZkFYaERBdGdhZw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC11906226%2F&v=928aRhhPP8I) [https://sportrxiv.org/index.php/serve...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbG9Xd2ZzdkU5QV9HbFJLMmRfZkM1MFlpSVFQQXxBQ3Jtc0tudk1vU2cyVXFTTWVsM3dSZmxlNndGVzZLZEg5QWlXeG9wZEZjMEtWdF9XV0Z5V29LUzROZnVuQnhzODBBRWl2dVlpeFZNZkpLLUlWdUxwX2xicDZLV045dFNSLTdENjN0bXRfR2JzSDFheFlDcjQ0MA&q=https%3A%2F%2Fsportrxiv.org%2Findex.php%2Fserver%2Fpreprint%2Fview%2F486%2F1085&v=928aRhhPP8I) [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbTZpWnpmQnU3UHpmRkRvLVQ0WXV5a2pCMmZDUXxBQ3Jtc0tuWUl4ZGxkR3U3VHYyeDJ0bjhEN3p5NzM1T2FsS2JFUS1kVkxVZGFLVWZtcGsyLVUzX1QxbFZvTE1jbXo3STlCVE15TGFWMy1MamJnVUNYcUk0cl9XTjduTExmM3UzeHFLVElVOWIwWlZ5cDEtUUxJdw&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F388004281&v=928aRhhPP8I) Timestamps: [0:00](https://www.youtube.com/watch?v=928aRhhPP8I) - My 1 year experiment recap [0:31](https://www.youtube.com/watch?v=928aRhhPP8I&t=31s) - Exercise 1 (Chest, Shoulders, Triceps) [2:44](https://www.youtube.com/watch?v=928aRhhPP8I&t=164s) - Exercise 2 (Chest) [4:13](https://www.youtube.com/watch?v=928aRhhPP8I&t=253s) - Exercise 3 (Back, Biceps) [6:54](https://www.youtube.com/watch?v=928aRhhPP8I&t=414s) - Exercise 4 (Shoulders) [9:16](https://www.youtube.com/watch?v=928aRhhPP8I&t=556s) - Exercise 5 (Back, Biceps) [10:57](https://www.youtube.com/watch?v=928aRhhPP8I&t=657s) - Exercise 6 (Triceps) [11:46](https://www.youtube.com/watch?v=928aRhhPP8I&t=706s) - Exercise 7 (Biceps) ------------------------------- Written by Jeff Nippard Directed by Bailey Wood and Jeff Nippard Filmed by Meraki Films Edited by Rickie Ho, Sam Ding, Jeff Nippard (Â Â [/Â coldgamerick](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbDNOZi12clRjOXZSR194VTFLSUliNGVEWFkzQXxBQ3Jtc0tuRDI2R2kyMXhoc29aM1NJTWhWUU5qQkNSY2FkbTl5REZUV2cyTDh2QjZrWFZ4Q0l6RmY3YWZFUFd5aVl0WUZMNi1JVHFBZHNvQXZOZnl6SktGNmtzSG1nYURwbFc4RUpvdGtzc29Qdmt4T09Qc1VnSQ&q=https%3A%2F%2Ftwitter.com%2Fcoldgamerick&v=928aRhhPP8I)Â Â ) Graphics by Rickie Ho, Sam Ding Music Arranged by Jeff Nippard Music sourced from Epidemic Sound ------------------------------- About me: I'm a Canadian natural pro bodybuilder and internationally-qualified powerlifter with a BSc in biochemistry/chemistry and a passion for science. I've been training for 15 years drug-free. I'm 5'5 and fluctuate between 160 lbs (lean) and 180 lbs (bulked). ------------------------------- Disclaimers: Jeff Nippard is not a doctor or a medical professional. Always consult a physician before starting any exercise program. Use of this information is strictly at your own risk. Jeff Nippard will not assume any liability for direct or indirect losses or damages that may result from the use of information contained in this video including but not limited to economic loss, injury, illness or death.",
    "chunk_index": 0,
    "bookmark_id": "3711e6c3-85a3-4fb6-a9c2-3a2ebd479853",
    "url": "https://www.youtube.com/watch?v=928aRhhPP8I",
    "title": "The Upper Body Workout I Followed For My 1 Year Transformation",
    "markdown": "Get my new Bodybuilding Transformation System (25% off code TRANSFORM): [https://jeffnippard.com/products/the-...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqblNpTWQxRVBLSHFCNklWbzRnbEhOcjlpbmxoQXxBQ3Jtc0tuRGdRSHBYeUpWTHVIQU55ZldxRUNfV0Q2SUxpSWpnVGxNM0c4bXJ4WjZod2VuS0FtRUk3TzN4MVdwbTZHNWtsc1VTaE1rOWxXdmFDSG41WW9pcUZxN0RUaG9mZmVvYmNoNTE2MU9meFd0SUNhem5XYw&q=https%3A%2F%2Fjeffnippard.com%2Fproducts%2Fthe-bodybuilding-transformation-system&v=928aRhhPP8I) My Nutrition App: [http://bit.ly/jeffmacrofactor](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqazUwQ2VjQldEdjVwdWVCdFRiVEE0RllQNkN4d3xBQ3Jtc0tsYlRwMHJLdVUzekstY1F3dDVnQmxrb0dEQ1ZBbzNfSG9TV3NOdTZaQ2pBVlZZX3BGZk5JejRITVVUYVAtYVlMMkRlSEwzZ2NVa05jTS0zcUp6SlhqTFNvaHR4VUQtVV9JMkpYZHpWZHF5Z2JyTHdJWQ&q=http%3A%2F%2Fbit.ly%2Fjeffmacrofactor&v=928aRhhPP8I) (Use code Jeff for a FREE 2 week trial) ------------------------------- Summary: In this video, I break down the exact upper body workout I used during my 365-day experiment. Iâ€™ll explain why I chose each exercise over similar options, share key technique cues, and highlight common mistakes to avoid. References: Incline Bench Press Hypertrophy [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGFkcDB3blVhb3pmelVLNHdaZkcyNWI1dUdIQXxBQ3Jtc0tuNmFydGpvSHBSZVlPX0doUFJydDllaGMwZlhMNjRNdEZWcjFUZERzYnpaVU9HU3BhVjlJTnN2STNFaE1VaFZKeWJDcnlVUTdaQlZDWV9VQU0wd2htNS05YXh5MFVNMDZwOXVIUlFtV2htcVFoZ0xBdw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC7449336%2F&v=928aRhhPP8I) Cable vs Dumbbell Lateral Raise [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbjN5QnFld0RIZ1hESkZOVEQ0QmJwblhzcmhiZ3xBQ3Jtc0ttemZrWmZqdXQ3amFmSEo2aG1NcXZaNXJQazc2YUlsbloxOFlfcUhLZnpTcVA1ZFFONGFWbkg5aDZzN0RLTlBXaUlvZ1RHS1d1Z1kxYkk1eEM2NWcwNmRVVFZuTUt3OEN3LU5PVkdlYTV3d192dkpkRQ&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F387157135&v=928aRhhPP8I) Biceps Studies [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqa2IydUVGaV9kaW1EU1dyUFlJWHZGb29CdUZhQXxBQ3Jtc0ttNWVmcHdqUy1oRkdvYlNLM0dTX1U2d3QxZHdCVENfTkxhdjZLTnNzWUE0WGozX3FHbXNraFA5ZWliQ3RiOW9JY1ZlM0s0U0tZd1ZlMUVFR3VXV2F3Ul9RTlZVOTVjWjJLbUR4d082ZkFYaERBdGdhZw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC11906226%2F&v=928aRhhPP8I) [https://sportrxiv.org/index.php/serve...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbG9Xd2ZzdkU5QV9HbFJLMmRfZkM1MFlpSVFQQXxBQ3Jtc0tudk1vU2cyVXFTTWVsM3dSZmxlNndGVzZLZEg5QWlXeG9wZEZjMEtWdF9XV0Z5V29LUzROZnVuQnhzODBBRWl2dVlpeFZNZkpLLUlWdUxwX2xicDZLV045dFNSLTdENjN0bXRfR2JzSDFheFlDcjQ0MA&q=https%3A%2F%2Fsportrxiv.org%2Findex.php%2Fserver%2Fpreprint%2Fview%2F486%2F1085&v=928aRhhPP8I) [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbTZpWnpmQnU3UHpmRkRvLVQ0WXV5a2pCMmZDUXxBQ3Jtc0tuWUl4ZGxkR3U3VHYyeDJ0bjhEN3p5NzM1T2FsS2JFUS1kVkxVZGFLVWZtcGsyLVUzX1QxbFZvTE1jbXo3STlCVE15TGFWMy1MamJnVUNYcUk0cl9XTjduTExmM3UzeHFLVElVOWIwWlZ5cDEtUUxJdw&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F388004281&v=928aRhhPP8I) Timestamps: [0:00](https://www.youtube.com/watch?v=928aRhhPP8I) - My 1 year experiment recap [0:31](https://www.youtube.com/watch?v=928aRhhPP8I&t=31s) - Exercise 1 (Chest, Shoulders, Triceps) [2:44](https://www.youtube.com/watch?v=928aRhhPP8I&t=164s) - Exercise 2 (Chest) [4:13](https://www.youtube.com/watch?v=928aRhhPP8I&t=253s) - Exercise 3 (Back, Biceps) [6:54](https://www.youtube.com/watch?v=928aRhhPP8I&t=414s) - Exercise 4 (Shoulders) [9:16](https://www.youtube.com/watch?v=928aRhhPP8I&t=556s) - Exercise 5 (Back, Biceps) [10:57](https://www.youtube.com/watch?v=928aRhhPP8I&t=657s) - Exercise 6 (Triceps) [11:46](https://www.youtube.com/watch?v=928aRhhPP8I&t=706s) - Exercise 7 (Biceps) ------------------------------- Written by Jeff Nippard Directed by Bailey Wood and Jeff Nippard Filmed by Meraki Films Edited by Rickie Ho, Sam Ding, Jeff Nippard (Â Â [/Â coldgamerick](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbDNOZi12clRjOXZSR194VTFLSUliNGVEWFkzQXxBQ3Jtc0tuRDI2R2kyMXhoc29aM1NJTWhWUU5qQkNSY2FkbTl5REZUV2cyTDh2QjZrWFZ4Q0l6RmY3YWZFUFd5aVl0WUZMNi1JVHFBZHNvQXZOZnl6SktGNmtzSG1nYURwbFc4RUpvdGtzc29Qdmt4T09Qc1VnSQ&q=https%3A%2F%2Ftwitter.com%2Fcoldgamerick&v=928aRhhPP8I)Â Â ) Graphics by Rickie Ho, Sam Ding Music Arranged by Jeff Nippard Music sourced from Epidemic Sound ------------------------------- About me: I'm a Canadian natural pro bodybuilder and internationally-qualified powerlifter with a BSc in biochemistry/chemistry and a passion for science. I've been training for 15 years drug-free. I'm 5'5 and fluctuate between 160 lbs (lean) and 180 lbs (bulked). ------------------------------- Disclaimers: Jeff Nippard is not a doctor or a medical professional. Always consult a physician before starting any exercise program. Use of this information is strictly at your own risk. Jeff Nippard will not assume any liability for direct or indirect losses or damages that may result from the use of information contained in this video including but not limited to economic loss, injury, illness or death.\n\nHow this was made\n\nAuto-dubbed\n\nAudio tracks for some languages were automatically generated. [Learn more](https://support.google.com/youtube/answer/15569972?hl=en)\n\n[](https://www.youtube.com/@JeffNippard)",
    "favicon": "https://www.youtube.com/s/desktop/a3c20ab4/img/favicon_32x32.png",
    "created_at": "2026-01-02 06:25:05.756419",
    "updated_at": "2026-01-02 06:25:05.756419",
    "similarity": 0.3598367213959617
  },
  {
    "embedding_id": "567e8ff2-979b-4f5f-9d85-c380ab321090",
    "matched_chunk": "vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```",
    "chunk_index": 3,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.10690267276183818
  },
  {
    "embedding_id": "f6b03341-a64c-49ff-a5b3-7622042368b2",
    "matched_chunk": "id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```",
    "chunk_index": 4,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.10382948323136842
  },
  {
    "embedding_id": "993f22e6-2580-4edf-8ee8-9ba3bed8b45c",
    "matched_chunk": "into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.",
    "chunk_index": 6,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.07497920095920563
  },
  {
    "embedding_id": "51fd8ad9-cee7-4025-8bf4-f2dcf7a73ce0",
    "matched_chunk": "id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';",
    "chunk_index": 5,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.0749657079577446
  },
  {
    "embedding_id": "be1244b1-6ff7-4125-b821-bebb77846a24",
    "matched_chunk": "from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "chunk_index": 8,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.07262112225138873
  },
  {
    "embedding_id": "0efeeba1-6960-4a8d-b2a2-468fa51dfe91",
    "matched_chunk": "the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)",
    "chunk_index": 7,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.045890944195873584
  },
  {
    "embedding_id": "60ea78db-fe35-4667-9535-b75351607999",
    "matched_chunk": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.",
    "chunk_index": 0,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.04255270347627471
  },
  {
    "embedding_id": "ff42863d-3a93-41ae-bf1e-4564fb4d1af7",
    "matched_chunk": "id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```",
    "chunk_index": 2,
    "bookmark_id": "23b5813f-3c53-4ac6-b9c1-7efb626d0bce",
    "url": "https://orm.drizzle.team/docs/sql#sql-template",
    "title": "Drizzle ORM - Magic sql`` operator",
    "markdown": "## Magical `sql` operator ðŸª„\n\nWhen working with an ORM library, there may be cases where you find it challenging to write a specific query using the provided ORM syntax. In such situations, you can resort to using raw queries, which involve constructing a query as a raw string. However, raw queries often lack the benefits of type safety and query parameterization.\n\nTo address this, many libraries have introduced the concept of an `sql` template. This template allows you to write more type-safe and parameterized queries, enhancing the overall safety and flexibility of your code. Drizzle, being a powerful ORM library, also supports the sql template.\n\nWith Drizzleâ€™s `sql` template, you can go even further in crafting queries. If you encounter difficulties in writing an entire query using the libraryâ€™s query builder, you can selectively use the `sql` template within specific sections of the Drizzle query. This flexibility enables you to employ the sql template in partial SELECT statements, WHERE clauses, ORDER BY clauses, HAVING clauses, GROUP BY clauses, and even in relational query builders.\n\nBy leveraging the capabilities of the sql template in Drizzle, you can maintain the advantages of type safety and query parameterization while achieving the desired query structure and complexity. This empowers you to create more robust and maintainable code within your application.\n\n## sqlâ€œ template[](#sql-template)\n\nOne of the most common usages you may encounter in other ORMs as well is the ability to use `sql` queries as-is for raw queries.\n\n```\nimport { sql } from 'drizzle-orm' \n\nconst id = 69;\nawait db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)\n```\n\nIt will generate the current query\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [69]\n```\n\nAny tables and columns provided to the sql parameter are automatically mapped to their corresponding SQL syntax with escaped names for tables, and the escaped table names are appended to column names.\n\nAdditionally, any dynamic parameters such as `${id}` will be mapped to the $1 placeholder, and the corresponding values will be moved to an array of values that are passed separately to the database.\n\nThis approach effectively prevents any potential SQL Injection vulnerabilities.\n\nPlease note that `sql<T>` does not perform any runtime mapping. The type you define using `sql<T>` is purely a helper for Drizzle. It is important to understand that there is no feasible way to determine the exact type dynamically, as SQL queries can be highly versatile and customizable.\n\nYou can define a custom type in Drizzle to be used in places where fields require a specific type other than `unknown`.\n\nThis feature is particularly useful in partial select queries, ensuring consistent typing for selected fields:\n\n```\n// without sql<T> type defined\nconst response: { lowerName: unknown }[] = await db.select({\n    lowerName: sql`lower(${usersTable.id})`\n}).from(usersTable);\n\n// with sql<T> type defined\nconst response: { lowerName: string }[] = await db.select({\n    lowerName: sql<string>`lower(${usersTable.id})`\n}).from(usersTable);\n```\n\n## `sql``.mapWith()`[](#sqlmapwith)\n\nFor the cases you need to make a runtime mapping for values passed from database driver to drizzle you can use `.mapWith()`\n\nThis function accepts different values, that will map response in runtime.\n\nYou can replicate a specific column mapping strategy as long as the interface inside mapWith is the same interface that is implemented by Column.\n\n```\nconst usersTable = pgTable('users', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n});\n\n//  at runtime this values will be mapped same as `text` column is mapped in drizzle\nsql`...`.mapWith(usersTable.name);\n```\n\nYou can also pass your own implementation for the `DriverValueDecoder` interface:\n\n```\nsql``.mapWith({\n\tmapFromDriverValue: (value: any) => {\n\t\tconst mappedValue = value;\n\t\t// mapping you want to apply\n\t\treturn mappedValue;\n\t},\n});\n    \n// or\nsql``.mapWith(Number);\n```\n\n## `sql``.as<T>()`[](#sqlast)\n\nIn different cases, it can sometimes be challenging to determine how to name a custom field that you want to use. You may encounter situations where you need to explicitly specify an alias for a field that will be selected. This can be particularly useful when dealing with complex queries.\n\nTo address these scenarios, we have introduced a helpful `.as('alias_name')` helper, which allows you to define an alias explicitly. By utilizing this feature, you can provide a clear and meaningful name for the field, making your queries more intuitive and readable.\n\n```\nsql`lower(usersTable.name)`.as('lower_name')\n```\n\n```\n... \"usersTable\".\"name\" as lower_name ...\n```\n\n## `sql.raw()`[](#sqlraw)\n\nThere are cases where you may not need to create parameterized values from input or map tables/columns to escaped ones. Instead, you might simply want to generate queries as they are. For such situations, we provide the `sql.raw()` function.\n\nThe `sql.raw()` function allows you to include raw SQL statements within your queries without any additional processing or escaping. This can be useful when you have pre-constructed SQL statements or when you need to incorporate complex or dynamic SQL code directly into your queries.\n\n```\nsql.raw(`select * from users where id = ${12}`);\n// vs\nsql`select * from users where id = ${12}`;\n```\n\n```\nselect * from users where id = 12;\n--> vs\nselect * from users where id = $1; --> [12]\n```\n\nYou can also utilize `sql.raw()` within the sql function, enabling you to include any raw string without escaping it through the main `sql` template function.\n\nBy using `sql.raw()` inside the `sql` function, you can incorporate unescaped raw strings directly into your queries. This can be particularly useful when you have specific SQL code or expressions that should remain untouched by the template functionâ€™s automatic escaping or modification.\n\n```\nsql`select * from ${usersTable} where id = ${12}`;\n// vs\nsql`select * from ${usersTable} where id = ${sql.raw(12)}`;\n```\n\n```\nselect * from \"users\" where id = $1; --> [12]\n--> vs\nselect * from \"users\" where id = 12;\n```\n\n## sql.fromList()[](#sqlfromlist)\n\nThe `sql` template generates sql chunks, which are arrays of SQL parts that will be concatenated into the query and params after applying the SQL to the database or query in Drizzle.\n\nIn certain scenarios, you may need to aggregate these chunks into an array using custom business logic and then concatenate them into a single SQL statement that can be passed to the database or query. For such cases, the fromList function can be quite useful.\n\nThe fromList function allows you to combine multiple SQL chunks into a single SQL statement. You can use it to aggregate and concatenate the individual SQL parts according to your specific requirements and then obtain a unified SQL query that can be executed.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tsqlChunks.push(sql` or `);\n}\n\nconst finalSql: SQL = sql.fromList(sqlChunks)\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.join()[](#sqljoin)\n\nIndeed, the `sql.join` function serves a similar purpose to the fromList helper. However, it provides additional flexibility when it comes to handling spaces between SQL chunks or specifying custom separators for concatenating the SQL chunks.\n\nWith `sql.join`, you can concatenate SQL chunks together using a specified separator. This separator can be any string or character that you want to insert between the chunks.\n\nThis is particularly useful when you have specific requirements for formatting or delimiting the SQL chunks. By specifying a custom separator, you can achieve the desired structure and formatting in the final SQL query.\n\n```\nconst sqlChunks: SQL[] = [];\n\nsqlChunks.push(sql`select * from users`);\n\n// some logic\n\nsqlChunks.push(sql`where`);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tsqlChunks.push(sql`id = ${i}`);\n\nif (i === 4) continue;\n    sqlChunks.push(sql`or`);\n}\n\nconst finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.append()[](#sqlappend)\n\nIf you have already generated SQL using the `sql` template, you can achieve the same behavior as `fromList` by using the append function to directly add a new chunk to the generated SQL.\n\nBy using the append function, you can dynamically add additional SQL chunks to the existing SQL string, effectively concatenating them together. This allows you to incorporate custom logic or business rules for aggregating the chunks into the final SQL query.\n\n```\nconst finalSql = sql`select * from users`;\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## sql.empty()[](#sqlempty)\n\nBy using sql.empty(), you can start with a blank SQL object and then dynamically append SQL chunks to it as needed. This allows you to construct the SQL query incrementally, applying custom logic or conditions to determine the contents of each chunk.\n\nOnce you have initialized the SQL object using sql.empty(), you can take advantage of the full range of sql template features such as parameterization, composition, and escaping. This empowers you to construct the SQL query in a flexible and controlled manner, adapting it to your specific requirements.\n\n```\nconst finalSql = sql.empty();\n\n// some logic\n\nfinalSql.append(sql`select * from users`);\n\n// some logic\n\nfinalSql.append(sql` where `);\n\n// some logic\n\nfor (let i = 0; i < 5; i++) {\n\tfinalSql.append(sql`id = ${i}`);\n\n\tif (i === 4) continue;\n\tfinalSql.append(sql` or `);\n}\n```\n\n```\nselect * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]\n```\n\n## Convert `sql` to string and params[](#convert-sql-to-string-and-params)\n\nIn all the previous examples, you observed the usage of SQL template syntax in TypeScript along with the generated SQL output.\n\nIf you need to obtain the query string and corresponding parameters generated from the SQL template, you must specify the database dialect you intend to generate the query for. Different databases have varying syntax for parameterization and escaping, so selecting the appropriate dialect is crucial.\n\nOnce you have chosen the dialect, you can utilize the corresponding implementationâ€™s functionality to convert the SQL template into the desired query string and parameter format. This ensures compatibility with the specific database system you are working with.\n\n```\nimport { PgDialect } from 'drizzle-orm/pg-core';\n\nconst pgDialect = new PgDialect();\npgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 12 ]\n```\n\n## `sql` select[](#sql-select)\n\nYou can use the sql functionality in partial select queries as well. Partial select queries allow you to retrieve specific fields or columns from a table rather than fetching the entire row.\n\nFor more detailed information about partial select queries, you can refer to the Core API documentation available at **[Core API docs](https://orm.drizzle.team/docs/select#basic-and-partial-select)**.\n\n**Select different custom fields from table**\n\nHere you can see a usage for **[`sql<T>`](https://orm.drizzle.team/docs/sql#sqlt)**, **[`sql``.mapWith()`](https://orm.drizzle.team/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](https://orm.drizzle.team/docs/sql#sqlast)**.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({\n    id: usersTable.id,\n    lowerName: sql<string>`lower(${usersTable.name})`,\n    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),\n    count: sql<number>`count(*)`.mapWith(Number) \n}).from(usersTable)\n```\n\n```\nselect `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;\n```\n\n## `sql` in where[](#sql-in-where)\n\nIndeed, Drizzle provides a set of available expressions that you can use within the sql template. However, it is true that databases often have a wider range of expressions available, including those provided through extensions or other means.\n\nTo ensure flexibility and enable you to utilize any expressions that are not natively supported by Drizzle, you have the freedom to write the SQL template directly using the sql function. This allows you to leverage the full power of SQL and incorporate any expressions or functionalities specific to your target database.\n\nBy using the sql template, you are not restricted to only the predefined expressions in Drizzle. Instead, you can express complex queries and incorporate any supported expressions that the underlying database system provides.\n\n**Filtering by `id` but with sql**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst id = 77\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`${usersTable.id} = ${id}`)\n```\n\n```\nselect * from \"users\" where \"users\".\"id\" = $1; --> [ 77 ]\n```\n\n**Advanced fulltext search where statement**\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nconst searchParam = \"Ale\"\n\nawait db.select()\n        .from(usersTable)\n        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)\n```\n\n```\nselect * from \"users\" where to_tsvector('simple', \"users\".\"name\") @@ to_tsquery('simple', '$1'); --> [ \"Ale\" ]\n```\n\n## `sql` in orderBy[](#sql-in-orderby)\n\nThe `sql` template can indeed be used in the ORDER BY clause when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)\n```\n\n```\nselect * from \"users\" order by \"users\".\"id\" desc nulls first;\n```\n\n## `sql` in having and groupBy[](#sql-in-having-and-groupby)\n\nThe `sql` template can indeed be used in the HAVING and GROUP BY clauses when you need specific functionality for ordering that is not available in Drizzle, but you prefer not to resort to raw SQL.\n\n```\nimport { sql } from 'drizzle-orm'\nimport { usersTable } from 'schema'\n\nawait db.select({ \n    projectId: usersTable.projectId,\n    count: sql<number>`count(${usersTable.id})`.mapWith(Number)\n}).from(usersTable)\n    .groupBy(sql`${usersTable.projectId}`)\n    .having(sql`count(${usersTable.id}) > 300`)\n```\n\n```\nselect \"project_id\", count(\"users\".\"id\") from users group by \"users\".\"project_id\" having count(\"users\".\"id\") > 300; \n```",
    "favicon": "https://orm.drizzle.team/favicon.ico",
    "created_at": "2026-01-02 06:22:11.468118",
    "updated_at": "2026-01-02 06:22:11.468118",
    "similarity": 0.028919195617389426
  },
  {
    "embedding_id": "811c84eb-5661-4ad9-87a5-f2b0d620c5f9",
    "matched_chunk": "or damages that may result from the use of information contained in this video including but not limited to economic loss, injury, illness or death.\n\nHow this was made\n\nAuto-dubbed\n\nAudio tracks for some languages were automatically generated. [Learn more](https://support.google.com/youtube/answer/15569972?hl=en)\n\n[](https://www.youtube.com/@JeffNippard)",
    "chunk_index": 1,
    "bookmark_id": "3711e6c3-85a3-4fb6-a9c2-3a2ebd479853",
    "url": "https://www.youtube.com/watch?v=928aRhhPP8I",
    "title": "The Upper Body Workout I Followed For My 1 Year Transformation",
    "markdown": "Get my new Bodybuilding Transformation System (25% off code TRANSFORM): [https://jeffnippard.com/products/the-...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqblNpTWQxRVBLSHFCNklWbzRnbEhOcjlpbmxoQXxBQ3Jtc0tuRGdRSHBYeUpWTHVIQU55ZldxRUNfV0Q2SUxpSWpnVGxNM0c4bXJ4WjZod2VuS0FtRUk3TzN4MVdwbTZHNWtsc1VTaE1rOWxXdmFDSG41WW9pcUZxN0RUaG9mZmVvYmNoNTE2MU9meFd0SUNhem5XYw&q=https%3A%2F%2Fjeffnippard.com%2Fproducts%2Fthe-bodybuilding-transformation-system&v=928aRhhPP8I) My Nutrition App: [http://bit.ly/jeffmacrofactor](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqazUwQ2VjQldEdjVwdWVCdFRiVEE0RllQNkN4d3xBQ3Jtc0tsYlRwMHJLdVUzekstY1F3dDVnQmxrb0dEQ1ZBbzNfSG9TV3NOdTZaQ2pBVlZZX3BGZk5JejRITVVUYVAtYVlMMkRlSEwzZ2NVa05jTS0zcUp6SlhqTFNvaHR4VUQtVV9JMkpYZHpWZHF5Z2JyTHdJWQ&q=http%3A%2F%2Fbit.ly%2Fjeffmacrofactor&v=928aRhhPP8I) (Use code Jeff for a FREE 2 week trial) ------------------------------- Summary: In this video, I break down the exact upper body workout I used during my 365-day experiment. Iâ€™ll explain why I chose each exercise over similar options, share key technique cues, and highlight common mistakes to avoid. References: Incline Bench Press Hypertrophy [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbGFkcDB3blVhb3pmelVLNHdaZkcyNWI1dUdIQXxBQ3Jtc0tuNmFydGpvSHBSZVlPX0doUFJydDllaGMwZlhMNjRNdEZWcjFUZERzYnpaVU9HU3BhVjlJTnN2STNFaE1VaFZKeWJDcnlVUTdaQlZDWV9VQU0wd2htNS05YXh5MFVNMDZwOXVIUlFtV2htcVFoZ0xBdw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC7449336%2F&v=928aRhhPP8I) Cable vs Dumbbell Lateral Raise [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbjN5QnFld0RIZ1hESkZOVEQ0QmJwblhzcmhiZ3xBQ3Jtc0ttemZrWmZqdXQ3amFmSEo2aG1NcXZaNXJQazc2YUlsbloxOFlfcUhLZnpTcVA1ZFFONGFWbkg5aDZzN0RLTlBXaUlvZ1RHS1d1Z1kxYkk1eEM2NWcwNmRVVFZuTUt3OEN3LU5PVkdlYTV3d192dkpkRQ&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F387157135&v=928aRhhPP8I) Biceps Studies [https://pmc.ncbi.nlm.nih.gov/articles...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqa2IydUVGaV9kaW1EU1dyUFlJWHZGb29CdUZhQXxBQ3Jtc0ttNWVmcHdqUy1oRkdvYlNLM0dTX1U2d3QxZHdCVENfTkxhdjZLTnNzWUE0WGozX3FHbXNraFA5ZWliQ3RiOW9JY1ZlM0s0U0tZd1ZlMUVFR3VXV2F3Ul9RTlZVOTVjWjJLbUR4d082ZkFYaERBdGdhZw&q=https%3A%2F%2Fpmc.ncbi.nlm.nih.gov%2Farticles%2FPMC11906226%2F&v=928aRhhPP8I) [https://sportrxiv.org/index.php/serve...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbG9Xd2ZzdkU5QV9HbFJLMmRfZkM1MFlpSVFQQXxBQ3Jtc0tudk1vU2cyVXFTTWVsM3dSZmxlNndGVzZLZEg5QWlXeG9wZEZjMEtWdF9XV0Z5V29LUzROZnVuQnhzODBBRWl2dVlpeFZNZkpLLUlWdUxwX2xicDZLV045dFNSLTdENjN0bXRfR2JzSDFheFlDcjQ0MA&q=https%3A%2F%2Fsportrxiv.org%2Findex.php%2Fserver%2Fpreprint%2Fview%2F486%2F1085&v=928aRhhPP8I) [https://www.researchgate.net/publicat...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbTZpWnpmQnU3UHpmRkRvLVQ0WXV5a2pCMmZDUXxBQ3Jtc0tuWUl4ZGxkR3U3VHYyeDJ0bjhEN3p5NzM1T2FsS2JFUS1kVkxVZGFLVWZtcGsyLVUzX1QxbFZvTE1jbXo3STlCVE15TGFWMy1MamJnVUNYcUk0cl9XTjduTExmM3UzeHFLVElVOWIwWlZ5cDEtUUxJdw&q=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F388004281&v=928aRhhPP8I) Timestamps: [0:00](https://www.youtube.com/watch?v=928aRhhPP8I) - My 1 year experiment recap [0:31](https://www.youtube.com/watch?v=928aRhhPP8I&t=31s) - Exercise 1 (Chest, Shoulders, Triceps) [2:44](https://www.youtube.com/watch?v=928aRhhPP8I&t=164s) - Exercise 2 (Chest) [4:13](https://www.youtube.com/watch?v=928aRhhPP8I&t=253s) - Exercise 3 (Back, Biceps) [6:54](https://www.youtube.com/watch?v=928aRhhPP8I&t=414s) - Exercise 4 (Shoulders) [9:16](https://www.youtube.com/watch?v=928aRhhPP8I&t=556s) - Exercise 5 (Back, Biceps) [10:57](https://www.youtube.com/watch?v=928aRhhPP8I&t=657s) - Exercise 6 (Triceps) [11:46](https://www.youtube.com/watch?v=928aRhhPP8I&t=706s) - Exercise 7 (Biceps) ------------------------------- Written by Jeff Nippard Directed by Bailey Wood and Jeff Nippard Filmed by Meraki Films Edited by Rickie Ho, Sam Ding, Jeff Nippard (Â Â [/Â coldgamerick](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbDNOZi12clRjOXZSR194VTFLSUliNGVEWFkzQXxBQ3Jtc0tuRDI2R2kyMXhoc29aM1NJTWhWUU5qQkNSY2FkbTl5REZUV2cyTDh2QjZrWFZ4Q0l6RmY3YWZFUFd5aVl0WUZMNi1JVHFBZHNvQXZOZnl6SktGNmtzSG1nYURwbFc4RUpvdGtzc29Qdmt4T09Qc1VnSQ&q=https%3A%2F%2Ftwitter.com%2Fcoldgamerick&v=928aRhhPP8I)Â Â ) Graphics by Rickie Ho, Sam Ding Music Arranged by Jeff Nippard Music sourced from Epidemic Sound ------------------------------- About me: I'm a Canadian natural pro bodybuilder and internationally-qualified powerlifter with a BSc in biochemistry/chemistry and a passion for science. I've been training for 15 years drug-free. I'm 5'5 and fluctuate between 160 lbs (lean) and 180 lbs (bulked). ------------------------------- Disclaimers: Jeff Nippard is not a doctor or a medical professional. Always consult a physician before starting any exercise program. Use of this information is strictly at your own risk. Jeff Nippard will not assume any liability for direct or indirect losses or damages that may result from the use of information contained in this video including but not limited to economic loss, injury, illness or death.\n\nHow this was made\n\nAuto-dubbed\n\nAudio tracks for some languages were automatically generated. [Learn more](https://support.google.com/youtube/answer/15569972?hl=en)\n\n[](https://www.youtube.com/@JeffNippard)",
    "favicon": "https://www.youtube.com/s/desktop/a3c20ab4/img/favicon_32x32.png",
    "created_at": "2026-01-02 06:25:05.756419",
    "updated_at": "2026-01-02 06:25:05.756419",
    "similarity": 0.014942353591322899
  }
]